package zip

import (
	"sort"
	"strings"
	"testing"

	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc"
	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc/mkzip"
	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc/mock"
	"github.com/google/go-cmp/cmp"
)

var dataBasic = []hdc.Entry{
	{Path: "readme.txt", Body: "This archive contains some text files."},
	{Path: "gopher.txt", Body: "Gopher names:\nGeorge\nGeoffrey\nGonzo"},
	{Path: "todo.txt", Body: "Get animal handling licence.\nWrite more examples."},
}
var dataMac = []hdc.Entry{
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "__MACOSX/somefile", Body: "some autogenerated data here that we don't care about"},
}

var dataNested = []hdc.Entry{
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "foo/somefile", Body: "i'm a file inside of foo"},
	{Path: "bar/somefile", Body: "i'm a file inside of bar"},
	{Path: "foo/bar/somefile", Body: "i'm a file inside of foo/bar"},
	{Path: "foo/bar/anotherfile", Body: "i'm another file inside of foo/bar"},
}

// note we also try various orderings between files and their corresponding macosx entries
var dataNestedMac = []hdc.Entry{
	{Path: "foo/bar/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/bar/__MACOSX/another", Body: "ignore this entry"},
	{Path: "__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "foo/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/somefile", Body: "i'm a file inside of foo"},
	{Path: "bar/somefile", Body: "i'm a file inside of bar"},
	{Path: "bar/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/bar/somefile", Body: "i'm a file inside of foo/bar"},
	{Path: "foo/bar/anotherfile", Body: "i'm another file inside of foo/bar"},
}

// filter returns a copy of the given slice with only the entries that do not contain the given substring
// it also sorts the entries lexically by name to match the zip reader.
func filter(entries []hdc.Entry, str string) []hdc.Entry {
	var out []hdc.Entry
	for _, e := range entries {
		if !strings.Contains(e.Path, str) {
			out = append(out, e)
		}
	}
	// sort by name
	sort.Slice(out, func(i, j int) bool {
		return out[i].Path < out[j].Path
	})

	return out
}

func TestIdentify(t *testing.T) {

	var tests = []struct {
		name string
		data []hdc.Entry
		want []hdc.Entry
		err  error
	}{
		{"basic", dataBasic, filter(dataBasic, "__MACOSX"), nil},
		{"nested", dataNested, nil, errUnsupported},
		{"mac", dataMac, filter(dataMac, "__MACOSX"), nil},
		{"nestedMac", dataNestedMac, nil, errUnsupported},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			var mfp mock.MockFingerPrinter
			_, zr := mkzip.Do(tt.data)
			err := FingerPrint(zr, "in-memory-test-directory", "in-memory-test-file", &mfp)
			if err != tt.err {
				t.Errorf("FingerPrint() error = %v, wantErr %v", err, tt.err)
			}
			if err != nil {
				return
			}

			if diff := cmp.Diff(tt.want, mfp.Entries); diff != "" {
				t.Errorf("TestIdentify() mismatch (-want +got):\n%s", diff)
			}
		})

	}
}
