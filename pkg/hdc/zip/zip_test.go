package zip

import (
	"os"
	"sort"
	"strings"
	"testing"

	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc"
	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc/mkzip"
	"github.com/Dieterbe/sandbox/homedirclean/pkg/hdc/mock"
	"github.com/google/go-cmp/cmp"
)

// TODO run same tests on "regular directory"? these are not specific to zip

var dataBasic = []hdc.Entry{
	{Path: "readme.txt", Body: "This archive contains some text files."},
	{Path: "gopher.txt", Body: "Gopher names:\nGeorge\nGeoffrey\nGonzo"},
	{Path: "todo.txt", Body: "Get animal handling licence.\nWrite more examples."},
}
var dataMac = []hdc.Entry{
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "__MACOSX/somefile", Body: "some autogenerated data here that we don't care about"},
}

var dataNested = []hdc.Entry{
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "foo/somefile", Body: "i'm a file inside of foo"},
	{Path: "bar/somefile", Body: "i'm a file inside of bar"},
	{Path: "foo/bar/somefile", Body: "i'm a file inside of foo/bar"},
	{Path: "foo/bar/anotherfile", Body: "i'm another file inside of foo/bar"},
}

// note we also try various orderings between files and their corresponding macosx entries
var dataNestedMac = []hdc.Entry{
	{Path: "foo/bar/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/bar/__MACOSX/another", Body: "ignore this entry"},
	{Path: "__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "somefile", Body: "This archive contains some text files."},
	{Path: "foo/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/somefile", Body: "i'm a file inside of foo"},
	{Path: "bar/somefile", Body: "i'm a file inside of bar"},
	{Path: "bar/__MACOSX/somefile", Body: "ignore this entry"},
	{Path: "foo/bar/somefile", Body: "i'm a file inside of foo/bar"},
	{Path: "foo/bar/anotherfile", Body: "i'm another file inside of foo/bar"},
}

// filter returns a copy of the given slice with only the entries that do not contain the given substring
func filter(entries []hdc.Entry, str string) []hdc.Entry {
	var out []hdc.Entry
	for _, e := range entries {
		if !strings.Contains(e.Path, str) {
			out = append(out, e)
		}
	}
	return out
}

// sortCopy sorts the entries lexically by name to match the zip reader, returning a copy.
// the input slice is not modified.
func sortCopy(entries []hdc.Entry) []hdc.Entry {
	out := make([]hdc.Entry, len(entries))
	copy(out, entries)

	// sort by name
	sort.Slice(out, func(i, j int) bool {
		return out[i].Path < out[j].Path
	})
	return out
}

func TestIdentify(t *testing.T) {

	var tests = []struct {
		name string
		data []hdc.Entry
		want []hdc.Entry
		err  error
	}{
		{"basic", dataBasic, dataBasic, nil},
		{"nested", dataNested, dataNested, nil},
		{"mac", dataMac, dataMac, nil},
		{"nestedMac", dataNestedMac, dataNestedMac, nil},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			var mfp mock.MockFingerPrinter
			_, zr := mkzip.Do(tt.data)
			err := WalkZip(zr, "in-memory-test-directory-"+tt.name, "in-memory-test-file-"+tt.name, mfp.Add, os.Stderr)
			if err != tt.err {
				t.Errorf("WalkZip() error = %v, wantErr %v", err, tt.err)
			}
			if err != nil {
				return
			}

			want := sortCopy(filter(tt.data, "__MACOSX"))

			if diff := cmp.Diff(want, mfp.Entries); diff != "" {
				t.Errorf("WalkZip() mismatch (-want +got):\n%s", diff)
			}
		})

	}
}
